---
title: "Introduction to R and Rstudio"
title-slide-attributes: 
  data-background-color: "#43464B"
  data-notes: "This session is about data wrangling with dplyr. I think this is the most important session - so do try and stay with it if you can. Dplyr is probably the one package I'll use for every R Project, and if you can be good at dplyr then you'll save yourself loads of time in the future." 
subtitle: "Session  - Cleaning data with {dplyr}"
author: "ZoÃ« Turner"
format:
  revealjs:
    theme: [default, nhsr-quarto.scss]
    logo: https://raw.githubusercontent.com/nhs-r-community/assets/main/logo/nhsr-logo.svg
    code-link: true
    css: nhsr-quarto.scss
    self-contained: true
    preview-links: true
execute: 
    echo: true
    eval: false
---


```{r}
#| echo: false
#| eval: true
#| label: "libs"
#| include: false
library(countdown)
library(readr)
library(dplyr)
```

```{r}
#| echo: false
#| eval: true
#| label: "load-data"
beds_data <- read_csv(url("https://raw.githubusercontent.com/nhs-r-community/intro_r_data/main/beds_data.csv"), 
                      col_types = cols(date = col_date(format = "%d/%m/%Y")), 
                      skip = 3)
```

<img src="img/session06/dplyr_wrangling.PNG" alt="Cartoon image with the word dplyr: go wrangling above. There are two fluffy characters with the bigger called dplyr being ridden by a smaller character with a hat like a cowboy. The cowboy is rounding up three others called data that look less friendly and are being caught with the cowboy's whip" class="center"/>

Artwork by @allison_horst

::: notes

This session is about data wrangling with dplyr. I think this is the most important session - so do try and stay with it if you can. Dplyr is probably the one package I'll use for every R Project, and if you can be good at dplyr then you'll save yourself loads of time in the future.

:::

## Wrangling

Is the reshaping or transforming of data into a format which is easier to work with  

This is often the largest part of many analyses and data science

::: notes

So dplyr is a package to help with data wrangling. When we say wrangling, we essentially mean the process of manipulating data into the format that we want it in. So after you load and maybe clean the data, you'll want to manipulate it into a certain format to help you with subsequent analysis or plotting.

:::

## A note on tidy data

Tidyverse functions work best with tidy data:

1. Each variable forms a column.
1. Each observation forms a row.

(Broadly, this means long rather than wide tables)

::: notes

Now the tidyverse suite of packages, as implied by the name, encourage data to be 'tidy' for subsequent working. This means that data should be in the form where each variable forms a column, and each observation forms a row. If you've worked with SQL, access or other databases, that shouldn't be new to you, but it's worth keeping in mind as the goal you should aim for.

:::

## {dplyr} package

- {dplyr} is a language for data manipulation  

:::incremental
- Most wrangling puzzles can be solved with knowledge of just a few {dplyr} verbs or functions 
- Many of the concepts of these functions exist in SQL but {dplyr} (and other packages) can extend this further
:::

::: notes

The way dplyr works is that it's structured around a series of functions or 'verbs' which perform common wrangling tasks, such as reordering, creating new variables, filtering and so on. This, together with the way the code is written, means that complex data manipulation can be concisely and easily expressible by chains of these verbs, as I'll come on to.

:::

## Some functions/verbs to start with

Some key verbs will help us gain a deeper understanding of our data sets.

Note `summarise()` can also be spelt `summarize()`

```{r}
dplyr::arrange()
dplyr::filter()
dplyr::mutate()
dplyr::summarise()
```

::: notes

In dplyr there are a handful of main functions or verbs, arrange, filter, mutate, group_by, and summarise. Note that summarise can be spelt either way. The main author of the tidyverse is a New Zealander, so British English spellings work too.

Some of these, like arrange and filter, should make intuitive sense, others, like mutate, are less intuative but will be covered in due course.

These functions are are simple in themselves but when put together can yield complex operations when built up.

:::

## Building with steps

These verbs aren't used independently of each other. 

Each can be a step in the code, like a recipe but can also be repeated.

A recipe starts with:

> potato then  
peel then  
slice into medium sized pieces then  
boil for 25 minutes then  
mash

::: notes

Now, to illustrate how these chains of verbs work, I'm going to draw the analogy with a cooking recipe. In a cooking recipe, for example for mashed potato, you're following a series of steps and carrying out those steps sequentially, to get the outcome you want.

:::

## Recipe as code

The potato is the object in R terms and the steps are verbs or functions

::: columns
::: {.column width="50%"}
Take a `potato` then  
`peel` then  
`slice` into medium sized pieces then  
`boil` for 25 minutes then  
`mash`
:::

::: {.column width="50%"}
`potato |> `  
`peel() |> `  
`slice(size = "medium") |> `  
`boil(time = 25) |> `  
`mash()`
:::
:::

the `|>` can be replaced with the word 'then' in this recipe scenario

::: notes

So, you start with the raw data, or an R object, in this analogy, the raw potato....
Then you perform the actions, so first you need to peel it. In the case of writing code, each of these action steps is a function or dplyr verb. So peel might be a peel() function.....
Slice might take an argument specifying exactly how thin you want the slices.....
The boil action might take an argument for how long for.....
And run start to finish, you get your mashed potato. Note that dplyr verbs are normally strung together with this |> symbol, between each step.

:::

## Pipe

::: columns
::: {.column width="40%"}
Shortcut key `Ctrl+Shift+m`

You might be familiar with the pipe `%>%` from {magrittr} and in {tidyverse} but the new pipe `|>` doesn't require any packages to run
:::

::: {.column width="60%"}
<img src="img/session-dplyr/native-pipe-options.PNG" alt="Screenshot of the Tools/Options wizard in the Code tab from the side and Editing at the top. Use native pipe operator option to select is highlighted."/>
:::
:::

::: notes

depending on the age of the code, you might see the magrittr pipe used %>%, but since R 4.1 there is a native pipe |> which people are now switching to. You can change the default pipe used for the shortcut key ctrl+shift+m in options / code 

:::

## Q1. Which organisation provided the highest number of Mental Health beds?

::: notes

Ok, lets actually try some of this out. You may still have the beds_csv messy data we loaded in before, which we did some cleaning on, but if not i'll demo this again (demo load in)

once, it's loaded in, we'll have a go at answering this question above 'Which organisation provided the highest number of Mental Health beds?'

:::

## arrange()

Reorder rows based on selected variable

```{r}
beds_data |> 
  arrange(beds_av)
```

::: notes

To do this, we can use the arrange function, which, as the name suggests, orders the dataset according to a particular variable.
(demo) - this gives the wrong answer, as default behaviour is to sort ascending, and we want the highest at the top

:::

## Descending data

We need descending order:

```{r}
#| code-line-numbers: "2"

beds_data |> 
  arrange(desc(beds_av))
```

`desc()` works for text and numeric variables

::: notes

To do this, we can use the arrange function, which, as the name suggests, orders the dataset according to a particular variable.
(demo) - this gives the wrong answer, as default behaviour is to sort ascending, and we want the highest at the top
To sort descending, you need to wrap the sort variable inside a desc() function
(demo)
And if you do that, you see that [trust] had the most mental health beds. But of course this data is monthly, so really we want a more specific question
(check everyone ok and got that result)

:::

## Q2. Which 2 organisations provided the highest number of MH beds in September 2018?

::: incremental
- We'll use `arrange()` as before to get the "highest number"
- But we require only observations with the date "September 2018"
:::

::: notes

So lets pick a specific period to look at, and exclude observations from other month-year pairs. This data is actually quarterly, so September 2018 is actually the 3 month period ending September 2018.
We'll need arrange(), but something else as well
We need something which will return only values from September 2018

:::

## filter()

The expression inside brackets should return TRUE or FALSE.
We are choosing rows where this expression is TRUE.

```{r}
#| code-line-numbers: "2"
beds_data |> 
  filter(date == "2018-09-01") 
```
</br>
  
::: {.fragment .fade-in}

### A negative test of equality

To exclude and test where the expression is NOT equal `!=`

```{r}
#| code-line-numbers: "2"
beds_data |> 
  filter(date != "2018-09-01") 
```
:::

::: notes

The verb we want here is filter()

And to use it, we pass in the condition we want. For a test of equality, we need to use two equals signs, and not equal to is an exclamation mark and an equals sign. The negative test of equality (i.e. return all but...) is exclamation mark then equals

:::

## Ordered and filtered

`filter()` first to reduce the number of rows to apply the next code to

```{r}
#| code-line-numbers: "2|3"
beds_data  |> 
  filter(date == "2018-09-01") |> 
  arrange(desc(beds_av)) 
```

::: notes

It's possible to do this the other way arround - i.e. sort then filter, rather than filter then sort. However useful to `filter()` early on in code to reduce the computational load - can make a big difference when data frames are millions of rows.

:::


## Find the top 2 organisations

This isn't a key function but useful and there are many other functions for `slice...`

```{r}
#| code-line-numbers: "4"
beds_data  |> 
  arrange(desc(beds_av)) |> 
  filter(date == "2018-09-01") |> 
  slice_head(n = 2)
```

::: notes

finally, because we're interested in only the top, we can use a slice function to return only the top 2 rows, in this case slice_head(). Slice_max() or something else could also be used to avoid having to arrange.
(demo and check everyone ok thus far)


:::

## Q3. Which organisations had the highest percentage bed occupancy in September 2018?

::: incremental
- We'll use `arrange()` as before to find "highest"
- We'll use `filter()` as before to restrict by date "September 2018"
- But we don't have a percentage variable in the data
:::

::: notes

Now we'll consider a slightly more focussed question, looking at the percentage occupancy

We'll keep arrange from before

and also filter

But we don't have a percentage occupancy variable

We need to create it...

:::

## Create new variables

= in this context is an alias not a test of equality

```{r}
#| code-line-numbers: "2|4"
beds_data |> 
  mutate(perc_occ = occ_av / beds_av) |> 
  filter(date == "2018-09-01") |> 
  arrange(desc(perc_occ)) 
```

::: notes
The verb to create new variables is mutate. It's the least intuitively named of the verbs, but one that you'll use often enough that you'll remember it. We name the new variable, then say how it's defined. In this case it's the occupied number of beds divided by the total number of beds, to give an occupancy percentage.

So we can slot that all together. So here we first create the variable (though we could have done it after the filter), then filter, then arrange according to the new variable descending
(demo)

Point out the differences between top two as both are 100 percent but very different sizes. Without denominators we can't really be sure what's happening.

:::

## Q4. What was the mean number of beds (for the dataset)?

::: incremental
- Let's first look at how we'd produce summary statistics like a mean
- And then see how this can be applied to groups of data like organisations
:::

::: notes

Ok, lets consider a more complex question about what the mean average bed numbers were at each point
So we probably need to create a mean at some point, but we also need to add together values across the whole dataset - so we can't just use mutate easily

:::

## summarise()

Collapses a single summary value

```{r}
#| code-line-numbers: "2"
beds_data |> 
  summarise(mean_beds = mean(beds_av))
```

::: notes

What we want to use is the summarise verb, which collapses the data frame and generates summary statistics for all observations. Here we are telling dplyr we want to summarise the dataframe with a summary variable means_beds, which is defined as the mean of available beds.
(demo)
Unfortunately, the result is NA. This is because we have missing variables, coded as NA in the dataframe

:::

## Missing values

We'll need to remove NA (not available) values to get a suitable mean. `TRUE` can also be `T`

```{r}
#| code-line-numbers: "3"
beds_data |> 
  summarise(mean_beds = mean(beds_av,
                             na.rm = TRUE)) 
```

::: notes

What we can do in this circumstance is to tell summarise to ignore the NA values, which we do by setting the na.rm argument to TRUE (all caps). You can use a capital T instead, but I'd advise against it. Your code is slightly more secure by writing it in full, and it's more readable as well
(demo)
And if you run that, you see that the result is an average of 300 beds for the whole dataset.

<!-- ::: -->

<!-- ## Have a go! -->

<!-- Instead of `mean()` use `median()` -->

<!-- ```{r} -->
<!-- object |>  -->
<!--   summarise(new_name = function_name(column_name, -->
<!--                                      na.rm = ???)) -->

<!-- ``` -->


<!-- Use a `sum()` statistic twice -->

<!-- ```{r} -->
<!-- object |>  -->
<!--   summarise(col_1 = function_name(beds_av, -->
<!--                                   na.rm = ???), -->
<!--             col_2 = function_name(occ_av, -->
<!--                                   na.rm = ???) -->
<!-- ) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- #| echo: false -->
<!-- countdown::countdown(minutes = 10, -->
<!--                      color_border = "#005EB8", -->
<!--                      color_text = "#005EB8", -->
<!--                      color_running_text = "white", -->
<!--                      color_running_background = "#005EB8", -->
<!--                      color_finished_text = "#005EB8", -->
<!--                      color_finished_background = "white", -->
<!--                      margin = "0.9em", -->
<!--                      font_size = "2em") -->
<!-- ``` -->

<!-- ::: notes -->

<!-- Ok, so I'm going to invite you to have a go yourselves now, to create summary statistics using this data, first to work out the median number of beds, with the median function, then also to return the total number of beds and the total number of occupied beds across all periods in the dataset. Strictly speaking these would be bed-quarters, which doesn't make sense as a unit, but for the purposes of learning it's ok. -->

<!-- I'll give you 10 mins, then we'll look at the answer. -->

<!-- ::: -->

<!-- ## Answer for summary statistics -->

<!-- `median()` -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- beds_data |>  -->
<!--   summarise(median_beds = median(beds_av, -->
<!--                                  na.rm = TRUE)) -->
<!-- ``` -->

<!-- `sum()` -->

<!-- ```{r} -->
<!-- #| eval: true -->
<!-- beds_data |>  -->
<!--   summarise(total_beds = sum(beds_av, na.rm = TRUE), -->
<!--             total_occupacy = sum(occ_av, na.rm = TRUE)) -->
<!-- ``` -->

<!-- ::: notes -->

<!-- Here's the code and the results you hopefully got. How did everyone do? Anyone want to volunteer whether they got those results or not? -->

<!-- (discuss a bit then move on) -->

<!-- ::: -->

:::

## Applying `summarise()` to groups

::: incremental
- Now we know how to use `summarise()`
- We'll produce a summary value for **each value of date**
:::

::: notes

typically when we compute summary statistics we want to produce them for particular groups. It is useful therefore to be able to group data by certain variables.

:::

## group_by() - temporary grouping

New for 2023 grouping can be added into the functions directly so is temporary.

Also used in `filter()` and `slice()` functions.

```{r}
#| code-line-numbers: "3"
beds_data |> 
  summarise(mean_beds = mean(beds_av, na.rm = TRUE),
            .by = date)
```

::: notes

The most modern way of doing this, new this year, is to add a .by argument to summarise
(demo)
As you can see, this gives us a mean_beds number for each value of date.

:::

## group_by() - persistent grouping

`group_by()` is a function that you may see in other code. 

It does nothing to the output alone.  
The change occurs behind the scenes. 

```{r}
#| code-line-numbers: "2"
beds_data |> 
  group_by(date) 

```

::: notes

Until recently, this was done by the group_by() function which you'll typically still see in most code or examples, so group_by() would generally preceed summarise in a chained pipe. If doing it this way, then best to use an ungroup() function after summarise to remove it, so you don't forget the dataframe is grouped.

:::

## Q5. Which organisations have the highest mean % bed occupancy? 

:::incremental
- `summarise()` using sum() for `total_beds` and `total_occupancy`. 
- Grouping in `summarise()` by organisations using `.by = `.
- `mutate()` the new 2 column data frame to create a percentage using the totals 
(occ / beds) 
- Order to find highest by using `arrange()`
:::

```{r}
#| echo: false
#| eval: true
countdown::countdown(minutes = 10,
                     color_border = "#005EB8",
                     color_text = "#005EB8",
                     color_running_text = "white",
                     color_running_background = "#005EB8",
                     color_finished_text = "#005EB8",
                     color_finished_background = "white",
                     margin = "0.9em",
                     font_size = "2em")
```

::: notes

Okay, one last question, this time for you to have a go at as a test of your understanding. Can you find which organisations have the highest mean % bed occupancy.

So to compute the mean occupancy, you'll need to use summarise to compute the two sums, of total and occupied beds, and you'll want to group by organisation using.by()

then take the result and mutate those numbers to add a column working out the ratio of occupied and total beds, to get a percentage occupancy, then, arrange the dataframe so the highest value is at the top. 

Don't forget that some values will be missing, so need to use na.rm = TRUE in your sum functions

Go!

:::

## Solutions

```{r}
beds_data |> 
  summarise(total_beds = sum(beds_av, na.rm = TRUE),
            total_occupancy = sum(occ_av, na.rm = TRUE),
            .by = date) |> 
  mutate(perc_occ = total_occupancy / total_beds) |> 
  arrange(desc(perc_occ))

```
</br>
```{r}
#| code-fold: true
#| code-summary: "Answer using the group_by() function"
beds_data |> 
  group_by(org_name) |> 
  summarise(total_beds = sum(beds_av, na.rm = TRUE),
            total_occupancy = sum(occ_av, na.rm = TRUE)) |> 
  mutate(perc_occ = total_occupancy / total_beds) |> 
  arrange(desc(perc_occ))

```

::: notes

Here's the code that is suggested, using .by and then, if you wanted to use the old group_by() function too. 

Demo code

How was that? Don't worry too much if didn't get it as it's a hard exercise.

:::

## End of session

::: notes

Ok, will run though some final dplyr things, just me demoing it this time

:::
